"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n  return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n  return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n  return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent) {\n  return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n  return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n  const placeholder = \"\\0\";\n  let temp = meta.replace(/\\\\\\\\/g, placeholder);\n  temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n  const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n  return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n  let meta = filter(\n    // @ts-expect-error: TODO handle this\n    element.data?.meta ?? element.properties?.metastring ?? \"\"\n  );\n  const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n  const title = titleMatch?.[1] ?? null;\n  meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n  const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n  const caption = captionMatch?.[1] ?? null;\n  meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n  let lang = defaultFallback;\n  if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n    lang = element.properties.className[0].replace(\"language-\", \"\");\n  }\n  return {\n    title,\n    caption,\n    lang,\n    meta\n  };\n}\nfunction getThemeNames(theme) {\n  if (isJSONTheme(theme)) {\n    return [theme.name];\n  }\n  if (typeof theme === \"string\") {\n    return [theme];\n  }\n  return Object.values(theme).map(\n    (theme2) => typeof theme2 === \"string\" ? theme2 : theme2.name\n  );\n}\nfunction replaceLineClass(element) {\n  if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n    const className = element.properties.className.filter((c) => c !== \"line\");\n    element.properties.className = className.length > 0 ? className : void 0;\n    element.properties[\"data-line\"] = \"\";\n  }\n}\nfunction getLineId(lineNumber, meta) {\n  const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n  if (!segments)\n    return null;\n  for (const segment of segments) {\n    const [range, id] = segment.split(\"#\");\n    if (!(range && id))\n      continue;\n    const match = range.match(/\\{(.*?)\\}/);\n    const capture = match?.[1];\n    if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n      return id;\n    }\n  }\n  return null;\n}\n\n// src/chars/splitElement.ts\nfunction splitElement({\n  elements,\n  elementToWrap,\n  innerString,\n  rightString,\n  leftString,\n  rest,\n  nextElementContinues,\n  index,\n  ignoreChars\n}) {\n  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n    return [elementToWrap, index];\n  }\n  let newIndex = index;\n  const textElement = elementToWrap.children[0];\n  if (isText(textElement)) {\n    textElement.value = innerString;\n  }\n  let rightStr = rightString;\n  const leftStr = leftString;\n  if (rest.length > 0) {\n    rightStr += rest.map((s) => s === \"\" ? innerString : innerString + s).join(\"\");\n  }\n  if (leftStr.length > 0) {\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: leftStr }]\n    });\n  }\n  if (rightStr.length > 0 && !nextElementContinues) {\n    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: rightStr }]\n    });\n  }\n  return [elementToWrap, index + 1];\n}\nfunction nextElementMaybeContinuesChars({\n  elements,\n  nextIndex,\n  remainingPart\n}) {\n  if (remainingPart === \"\") {\n    return false;\n  }\n  const nextNode = elements[nextIndex];\n  const content = getContent(nextNode);\n  if (!content) {\n    return false;\n  }\n  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n  const overlap = findOverlap(content, remainingPart);\n  if (overlap === remainingPart && content.startsWith(remainingPart)) {\n    return true;\n  }\n  if (includesNext) {\n    return nextElementMaybeContinuesChars({\n      elements,\n      nextIndex: nextIndex + 1,\n      remainingPart: remainingPart.replace(content, \"\")\n    });\n  }\n  return false;\n}\nfunction getContent(node) {\n  if (!node)\n    return;\n  return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n  if (b.length === 0) {\n    return \"\";\n  }\n  if (a.endsWith(b)) {\n    return b;\n  }\n  if (a.indexOf(b) >= 0) {\n    return b;\n  }\n  return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n  return s.split(\"\").reverse().join(\"\");\n}\n\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n  const toWrap = [];\n  let charsSoFar = \"\";\n  if (element.children) {\n    const elements = element.children;\n    for (let i = startIndex; i < elements.length; i++) {\n      const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n      if (remaining === \"\") {\n        return toWrap;\n      }\n      const maybeElement = elements[i];\n      if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n      Object.hasOwn(\n        maybeElement.properties ?? {},\n        \"rehype-pretty-code-visited\"\n      )) {\n        continue;\n      }\n      const content = getContent(maybeElement) || \"\";\n      if (content === chars || charsSoFar + content === chars) {\n        toWrap.push({ element: maybeElement, index: i });\n        return toWrap;\n      }\n      if (chars.startsWith(charsSoFar + content)) {\n        if (nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: remaining.replace(content, \"\")\n        })) {\n          toWrap.push({ element: elements[i], index: i });\n          charsSoFar += content;\n          continue;\n        }\n      }\n      const overlap = findOverlap(content, remaining);\n      const partialMatch = overlap && remaining.startsWith(overlap);\n      if (partialMatch) {\n        const nextPart = remaining.replace(overlap, \"\");\n        if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: nextPart\n        })) {\n          continue;\n        }\n        const splitParts = content.split(overlap);\n        const [leftPart, rightPart, ...rest] = splitParts;\n        if (rightPart || leftPart || rest.length > 0) {\n          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n          const nextNodeOverlap = findOverlap(withNextNode, remaining);\n          const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n            const rightString = rightPart.replace(overlap, \"\");\n            const innerString = overlap;\n            const leftString = content.substring(0, splitIndex);\n            const nextElementContinues = nextElementMaybeContinuesChars({\n              elements,\n              nextIndex: i + 1,\n              remainingPart: nextPart\n            });\n            const [newElement, updatedIndex] = splitElement({\n              elements,\n              elementToWrap: elements[i],\n              innerString,\n              rightString,\n              leftString,\n              rest,\n              nextElementContinues,\n              index: i,\n              ignoreChars\n            });\n            charsSoFar += overlap;\n            toWrap.push({\n              element: newElement,\n              index: updatedIndex\n            });\n          }\n        }\n      }\n    }\n  }\n  return toWrap;\n}\n\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n  if (!elementsToWrap || elementsToWrap.length === 0) {\n    return;\n  }\n  const [{ element }] = elementsToWrap;\n  if (ignoreWord) {\n    if (element.properties) {\n      element.properties[\"rehype-pretty-code-visited\"] = \"\";\n    }\n    return;\n  }\n  if (elementsToWrap.length > 1) {\n    parentElement.children.splice(\n      elementsToWrap[0].index,\n      elementsToWrap.length,\n      {\n        type: \"element\",\n        tagName: \"mark\",\n        properties: { \"data-highlighted-chars-mark\": \"\" },\n        children: elementsToWrap.map(({ element: element3 }) => element3)\n      }\n    );\n    const element2 = parentElement.children[elementsToWrap[0].index];\n    if (!isElement(element2)) {\n      return;\n    }\n    const wordStr = element2.children.reduce((acc, node) => {\n      const textElement = isElement(node) ? node.children[0] : null;\n      if (isText(textElement)) {\n        return acc + textElement.value;\n      }\n      return acc;\n    }, \"\");\n    const id = options.idsMap.get(wordStr);\n    element2.properties = element2.properties || {};\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    onVisitHighlightedChars?.(element2, id);\n  } else {\n    const [{ element: element2 }] = elementsToWrap;\n    const textElement = element2.children[0];\n    if (!isText(textElement)) {\n      return;\n    }\n    const id = options.idsMap.get(textElement.value);\n    element2.properties = element2.properties || {};\n    element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    element2.children = [\n      {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          style: element2.properties.style\n        },\n        children: element2.children\n      }\n    ];\n    element2.properties.style = void 0;\n    onVisitHighlightedChars?.(element2, id);\n  }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n  const { ranges = [] } = options;\n  const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n  charsList.forEach((chars, index) => {\n    if (chars && textContent?.includes(chars)) {\n      let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n      let startIndex = 0;\n      while (textContent2.includes(chars)) {\n        const currentCharsRange = ranges[index] || [];\n        const id = `${chars}-${index}`;\n        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n        const elementsToWrap = getElementsToHighlight(\n          element,\n          chars,\n          startIndex,\n          ignoreChars\n        );\n        if (elementsToWrap.length === 0)\n          break;\n        wrapHighlightedChars(\n          element,\n          elementsToWrap,\n          options,\n          ignoreChars,\n          onVisitHighlightedChars\n        );\n        startIndex = Math.max(\n          elementsToWrap[elementsToWrap.length - 1].index - 2,\n          0\n        );\n        textContent2 = element.children.map((childNode) => {\n          const props = isElement(childNode) ? childNode.properties : {};\n          if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n            return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n          }\n        }).join(\"\");\n      }\n    }\n  });\n  element.children.forEach((childNode) => {\n    if (!isElement(childNode))\n      return;\n    if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n      childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n    }\n  });\n}\n\n// src/index.ts\nfunction apply(element, {\n  tree,\n  lang,\n  title,\n  caption,\n  inline = false,\n  keepBackground = true,\n  grid = true,\n  lineNumbersMaxDigits = 1,\n  theme,\n  onVisitTitle,\n  onVisitCaption\n}) {\n  element.tagName = inline ? \"span\" : \"figure\";\n  element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n  const codeData = element.children[0]?.data;\n  element.children = [tree].map((tree2) => {\n    const pre = tree2.children[0];\n    const themeNames = getThemeNames(theme);\n    const themeNamesString = themeNames.join(\" \");\n    if (!(isElement(pre) && pre.properties)) {\n      return [];\n    }\n    const code = pre.children[0];\n    if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n      const className = pre.properties.className.filter(\n        (c) => c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true)\n      );\n      pre.properties.className = className.length > 0 ? className : void 0;\n    }\n    if (!keepBackground) {\n      pre.properties.style = void 0;\n    }\n    pre.properties[\"data-language\"] = lang;\n    pre.properties[\"data-theme\"] = themeNamesString;\n    if (!(isElement(code) && code.properties)) {\n      return [];\n    }\n    code.properties[\"data-language\"] = lang;\n    code.properties[\"data-theme\"] = themeNamesString;\n    code.data = codeData;\n    if (inline) {\n      if (keepBackground) {\n        code.properties.style = pre.properties.style;\n      }\n      return code;\n    }\n    if (grid) {\n      if (code.properties.style) {\n        code.properties.style += \"display: grid;\";\n      } else {\n        code.properties.style = \"display: grid;\";\n      }\n    }\n    if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n      code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n    }\n    const fragments = [];\n    if (title) {\n      const elementContent = {\n        type: \"element\",\n        tagName: caption ? \"div\" : \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-title\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: title }]\n      };\n      onVisitTitle?.(elementContent);\n      fragments.push(elementContent);\n    }\n    fragments.push(pre);\n    if (caption) {\n      const elementContent = {\n        type: \"element\",\n        tagName: \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-caption\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: caption }]\n      };\n      onVisitCaption?.(elementContent);\n      fragments.push(elementContent);\n    }\n    return fragments;\n  }).flatMap((c) => c);\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { fragment: true });\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n  const {\n    grid = true,\n    theme = \"github-dark-dimmed\",\n    keepBackground = true,\n    defaultLang = \"\",\n    tokensMap = {},\n    filterMetaString = (v) => v,\n    getHighlighter: getHighlighter$1 = shiki__WEBPACK_IMPORTED_MODULE_0__.getHighlighter,\n    transformers,\n    onVisitLine,\n    onVisitHighlightedLine,\n    onVisitHighlightedChars,\n    onVisitTitle,\n    onVisitCaption\n  } = options;\n  const key = JSON.stringify(theme);\n  let cachedHighlighter = globalHighlighterCache.get(key);\n  if (!cachedHighlighter) {\n    cachedHighlighter = getHighlighter$1({\n      themes: isJSONTheme(theme) || typeof theme === \"string\" ? [theme] : Object.values(theme),\n      langs: [\"plaintext\"]\n    });\n    globalHighlighterCache.set(key, cachedHighlighter);\n  }\n  const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n  const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n  function getOptions(lang, meta) {\n    const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n    const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n    return {\n      lang,\n      meta: { __raw: meta },\n      transformers,\n      defaultColor: typeof theme === \"string\" ? theme : false,\n      ...multipleThemes ? { themes: multipleThemes } : { theme: singleTheme }\n    };\n  }\n  return async (tree) => {\n    const langsToLoad = /* @__PURE__ */ new Set();\n    const highlighter = await cachedHighlighter;\n    if (!highlighter)\n      return;\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n        if (lang && lang[0] !== \".\") {\n          langsToLoad.add(lang);\n        }\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const { lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (lang) {\n          langsToLoad.add(lang);\n        }\n      }\n    });\n    try {\n      await Promise.allSettled(\n        Array.from(langsToLoad).map((lang) => {\n          try {\n            return highlighter.loadLanguage(\n              lang\n            );\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        })\n      );\n    } catch (e) {\n      console.error(e);\n    }\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n        const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n        textElement.value = strippedValue;\n        const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n        const isLang = lang[0] !== \".\";\n        if (!lang)\n          return;\n        let codeTree;\n        if (isLang) {\n          try {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(lang))\n            );\n          } catch {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\"))\n            );\n          }\n        } else {\n          const themeNames = getThemeNames(theme);\n          const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n          const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n          const colorsByTheme = themeNames.map(\n            (name) => name ? highlighter.getTheme(name).settings.find(\n              ({ scope }) => scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1))\n            )?.settings.foreground ?? \"inherit\" : \"inherit\"\n          );\n          if (isMultiTheme && themeKeys) {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"${themeKeys.map((key2, i) => `--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`\n            );\n          } else {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`\n            );\n          }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n        apply(element, {\n          tree: codeTree,\n          lang: isLang ? lang : \".token\",\n          inline: true,\n          keepBackground,\n          theme\n        });\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const textElement = codeElement.children[0];\n        const { title, caption, meta, lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (!lang || lang === \"math\")\n          return;\n        const lineNumbers = [];\n        if (meta) {\n          const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n          for (const match of matches) {\n            if (match[1]) {\n              lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n            }\n          }\n        }\n        let lineNumbersMaxDigits = 0;\n        const lineIdMap = /* @__PURE__ */ new Map();\n        const charsList = [];\n        const charsListNumbers = [];\n        const charsListIdMap = /* @__PURE__ */ new Map();\n        const charsMatches = meta ? [\n          ...meta.matchAll(\n            /(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g\n          )\n        ] : void 0;\n        lineNumbers.forEach((lineNumber) => {\n          const id = getLineId(lineNumber, meta);\n          id && lineIdMap.set(lineNumber, id);\n        });\n        if (Array.isArray(charsMatches)) {\n          charsMatches.forEach((name) => {\n            const { chars, charsIdAndOrRange } = name.groups;\n            charsList.push(chars);\n            if (charsIdAndOrRange === \"\") {\n              charsListNumbers.push([]);\n            } else {\n              const [range, id] = charsIdAndOrRange.split(\"#\");\n              range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n              id && charsListIdMap.set(chars, id);\n            }\n          });\n        }\n        if (!isText(textElement))\n          return;\n        const strippedValue = textElement.value.replace(/\\n$/, \"\");\n        let codeTree;\n        try {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(strippedValue, getOptions(lang, meta))\n          );\n        } catch {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(\n              strippedValue,\n              getOptions(\"plaintext\", meta)\n            )\n          );\n        }\n        let lineCounter = 0;\n        const charsHighlighterOptions = {\n          ranges: charsListNumbers,\n          idsMap: charsListIdMap,\n          counterMap: /* @__PURE__ */ new Map()\n        };\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2) => {\n          if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n            if (element2.properties) {\n              element2.properties[\"data-line-numbers\"] = \"\";\n            }\n            const lineNumbersStartAtMatch = reverseString(meta).match(\n              /(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/\n            );\n            const startNumberString = lineNumbersStartAtMatch?.[1];\n            if (startNumberString) {\n              const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n              lineNumbersMaxDigits = startAt;\n              if (element2.properties) {\n                element2.properties.style = `counter-set: line ${startAt};`;\n              }\n            }\n          }\n          if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n            if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n              element2.children = [{ type: \"text\", value: \" \" }];\n            }\n            replaceLineClass(element2);\n            onVisitLine?.(element2);\n            lineCounter++;\n            if (lineNumbers.includes(lineCounter)) {\n              element2.properties[\"data-highlighted-line\"] = \"\";\n              const lineId = lineIdMap.get(lineCounter);\n              if (lineId) {\n                element2.properties[\"data-highlighted-line-id\"] = lineId;\n              }\n              onVisitHighlightedLine?.(element2, lineId);\n            }\n            charsHighlighter(\n              element2,\n              charsList,\n              charsHighlighterOptions,\n              onVisitHighlightedChars\n            );\n            lineNumbersMaxDigits++;\n          }\n        });\n        apply(element, {\n          tree: codeTree,\n          lang,\n          title,\n          caption,\n          keepBackground,\n          grid,\n          lineNumbersMaxDigits,\n          theme,\n          onVisitTitle,\n          onVisitCaption\n        });\n      }\n    });\n  };\n}\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDRTtBQUNNO0FBQ0E7QUFDYjtBQUNLOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUcsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBLG1CQUFtQixnREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiw4QkFBOEI7QUFDakQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiwrQkFBK0I7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0Esd0JBQXdCLDZEQUFRO0FBQ2hDLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2Fhcy10ZW1wbGF0ZS1tYWdpY3VpLy4vbm9kZV9tb2R1bGVzL3JlaHlwZS1wcmV0dHktY29kZS9kaXN0L2luZGV4LmpzPzBkN2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SGlnaGxpZ2h0ZXIgfSBmcm9tICdzaGlraSc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQnO1xuaW1wb3J0IHsgdG9TdHJpbmcgfSBmcm9tICdoYXN0LXV0aWwtdG8tc3RyaW5nJztcbmltcG9ydCByYW5nZVBhcnNlcjIgZnJvbSAncGFyc2UtbnVtZXJpYy1yYW5nZSc7XG5pbXBvcnQgeyB1bmlmaWVkIH0gZnJvbSAndW5pZmllZCc7XG5pbXBvcnQgcmVoeXBlUGFyc2UgZnJvbSAncmVoeXBlLXBhcnNlJztcblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBpc0pTT05UaGVtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyBPYmplY3QuaGFzT3duKHZhbHVlLCBcInRva2VuQ29sb3JzXCIpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUudHlwZSA9PT0gXCJlbGVtZW50XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS50eXBlID09PSBcInRleHRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcImNvZGVcIiAmJiBpc0VsZW1lbnQocGFyZW50KSAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJwcmVcIiB8fCBlbGVtZW50LnRhZ05hbWUgPT09IFwiaW5saW5lQ29kZVwiO1xufVxuZnVuY3Rpb24gaXNCbG9ja0NvZGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcInByZVwiICYmIEFycmF5LmlzQXJyYXkoZWxlbWVudC5jaGlsZHJlbikgJiYgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgaXNFbGVtZW50KGVsZW1lbnQuY2hpbGRyZW5bMF0pICYmIGVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gXCJjb2RlXCI7XG59XG5mdW5jdGlvbiBnZXRJbmxpbmVDb2RlTGFuZyhtZXRhLCBkZWZhdWx0RmFsbGJhY2tMYW5nKSB7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gXCJcXDBcIjtcbiAgbGV0IHRlbXAgPSBtZXRhLnJlcGxhY2UoL1xcXFxcXFxcL2csIHBsYWNlaG9sZGVyKTtcbiAgdGVtcCA9IHRlbXAucmVwbGFjZSgvXFxcXCh7OlthLXpBLVouLV0rfSkkLywgXCIkMVwiKTtcbiAgY29uc3QgbGFuZyA9IHRlbXAubWF0Y2goL3s6KFthLXpBLVouLV0rKX0kLyk/LlsxXTtcbiAgcmV0dXJuIGxhbmc/LnJlcGxhY2UobmV3IFJlZ0V4cChwbGFjZWhvbGRlciwgXCJnXCIpLCBcIlxcXFxcIikgfHwgZGVmYXVsdEZhbGxiYWNrTGFuZztcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tNZXRhU3RyaW5nKGVsZW1lbnQsIGZpbHRlciwgZGVmYXVsdEZhbGxiYWNrKSB7XG4gIGxldCBtZXRhID0gZmlsdGVyKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRPRE8gaGFuZGxlIHRoaXNcbiAgICBlbGVtZW50LmRhdGE/Lm1ldGEgPz8gZWxlbWVudC5wcm9wZXJ0aWVzPy5tZXRhc3RyaW5nID8/IFwiXCJcbiAgKTtcbiAgY29uc3QgdGl0bGVNYXRjaCA9IG1ldGEubWF0Y2goL3RpdGxlPVwiKFteXCJdKilcIi8pO1xuICBjb25zdCB0aXRsZSA9IHRpdGxlTWF0Y2g/LlsxXSA/PyBudWxsO1xuICBtZXRhID0gbWV0YS5yZXBsYWNlKHRpdGxlTWF0Y2g/LlswXSA/PyBcIlwiLCBcIlwiKTtcbiAgY29uc3QgY2FwdGlvbk1hdGNoID0gbWV0YS5tYXRjaCgvY2FwdGlvbj1cIihbXlwiXSopXCIvKTtcbiAgY29uc3QgY2FwdGlvbiA9IGNhcHRpb25NYXRjaD8uWzFdID8/IG51bGw7XG4gIG1ldGEgPSBtZXRhLnJlcGxhY2UoY2FwdGlvbk1hdGNoPy5bMF0gPz8gXCJcIiwgXCJcIik7XG4gIGxldCBsYW5nID0gZGVmYXVsdEZhbGxiYWNrO1xuICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkoZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgJiYgdHlwZW9mIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0gPT09IFwic3RyaW5nXCIgJiYgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXS5zdGFydHNXaXRoKFwibGFuZ3VhZ2UtXCIpKSB7XG4gICAgbGFuZyA9IGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0ucmVwbGFjZShcImxhbmd1YWdlLVwiLCBcIlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRpdGxlLFxuICAgIGNhcHRpb24sXG4gICAgbGFuZyxcbiAgICBtZXRhXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaGVtZU5hbWVzKHRoZW1lKSB7XG4gIGlmIChpc0pTT05UaGVtZSh0aGVtZSkpIHtcbiAgICByZXR1cm4gW3RoZW1lLm5hbWVdO1xuICB9XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3RoZW1lXTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGVtZSkubWFwKFxuICAgICh0aGVtZTIpID0+IHR5cGVvZiB0aGVtZTIgPT09IFwic3RyaW5nXCIgPyB0aGVtZTIgOiB0aGVtZTIubmFtZVxuICApO1xufVxuZnVuY3Rpb24gcmVwbGFjZUxpbmVDbGFzcyhlbGVtZW50KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQucHJvcGVydGllcz8uY2xhc3NOYW1lKSAmJiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKFwibGluZVwiKSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUuZmlsdGVyKChjKSA9PiBjICE9PSBcImxpbmVcIik7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS5sZW5ndGggPiAwID8gY2xhc3NOYW1lIDogdm9pZCAwO1xuICAgIGVsZW1lbnQucHJvcGVydGllc1tcImRhdGEtbGluZVwiXSA9IFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExpbmVJZChsaW5lTnVtYmVyLCBtZXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbWV0YS5tYXRjaCgvXFx7W159XStcXH0jW2EtekEtWjAtOV0rL2cpO1xuICBpZiAoIXNlZ21lbnRzKVxuICAgIHJldHVybiBudWxsO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCBbcmFuZ2UsIGlkXSA9IHNlZ21lbnQuc3BsaXQoXCIjXCIpO1xuICAgIGlmICghKHJhbmdlICYmIGlkKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1hdGNoID0gcmFuZ2UubWF0Y2goL1xceyguKj8pXFx9Lyk7XG4gICAgY29uc3QgY2FwdHVyZSA9IG1hdGNoPy5bMV07XG4gICAgaWYgKGNhcHR1cmUgJiYgcmFuZ2VQYXJzZXIyKGNhcHR1cmUpLmluY2x1ZGVzKGxpbmVOdW1iZXIpKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvY2hhcnMvc3BsaXRFbGVtZW50LnRzXG5mdW5jdGlvbiBzcGxpdEVsZW1lbnQoe1xuICBlbGVtZW50cyxcbiAgZWxlbWVudFRvV3JhcCxcbiAgaW5uZXJTdHJpbmcsXG4gIHJpZ2h0U3RyaW5nLFxuICBsZWZ0U3RyaW5nLFxuICByZXN0LFxuICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgaW5kZXgsXG4gIGlnbm9yZUNoYXJzXG59KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudFRvV3JhcCkgJiYgZWxlbWVudFRvV3JhcC5jaGlsZHJlbj8uWzBdPy50eXBlICE9PSBcInRleHRcIiB8fCBpZ25vcmVDaGFycykge1xuICAgIHJldHVybiBbZWxlbWVudFRvV3JhcCwgaW5kZXhdO1xuICB9XG4gIGxldCBuZXdJbmRleCA9IGluZGV4O1xuICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnRUb1dyYXAuY2hpbGRyZW5bMF07XG4gIGlmIChpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgdGV4dEVsZW1lbnQudmFsdWUgPSBpbm5lclN0cmluZztcbiAgfVxuICBsZXQgcmlnaHRTdHIgPSByaWdodFN0cmluZztcbiAgY29uc3QgbGVmdFN0ciA9IGxlZnRTdHJpbmc7XG4gIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICByaWdodFN0ciArPSByZXN0Lm1hcCgocykgPT4gcyA9PT0gXCJcIiA/IGlubmVyU3RyaW5nIDogaW5uZXJTdHJpbmcgKyBzKS5qb2luKFwiXCIpO1xuICB9XG4gIGlmIChsZWZ0U3RyLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7IC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllcyB9LFxuICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogbGVmdFN0ciB9XVxuICAgIH0pO1xuICB9XG4gIGlmIChyaWdodFN0ci5sZW5ndGggPiAwICYmICFuZXh0RWxlbWVudENvbnRpbnVlcykge1xuICAgIG5ld0luZGV4ID0gbGVmdFN0ci5sZW5ndGggPiAwID8gbmV3SW5kZXggKyAyIDogbmV3SW5kZXggKyAxO1xuICAgIGVsZW1lbnRzLnNwbGljZShuZXdJbmRleCwgMCwge1xuICAgICAgLi4uZWxlbWVudFRvV3JhcCxcbiAgICAgIHByb3BlcnRpZXM6IHsgLi4uZWxlbWVudFRvV3JhcC5wcm9wZXJ0aWVzIH0sXG4gICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiByaWdodFN0ciB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBbZWxlbWVudFRvV3JhcCwgaW5kZXggKyAxXTtcbn1cbmZ1bmN0aW9uIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gIGVsZW1lbnRzLFxuICBuZXh0SW5kZXgsXG4gIHJlbWFpbmluZ1BhcnRcbn0pIHtcbiAgaWYgKHJlbWFpbmluZ1BhcnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbmV4dE5vZGUgPSBlbGVtZW50c1tuZXh0SW5kZXhdO1xuICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudChuZXh0Tm9kZSk7XG4gIGlmICghY29udGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpbmNsdWRlc05leHQgPSBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkgfHwgcmVtYWluaW5nUGFydC5zdGFydHNXaXRoKGNvbnRlbnQpO1xuICBjb25zdCBvdmVybGFwID0gZmluZE92ZXJsYXAoY29udGVudCwgcmVtYWluaW5nUGFydCk7XG4gIGlmIChvdmVybGFwID09PSByZW1haW5pbmdQYXJ0ICYmIGNvbnRlbnQuc3RhcnRzV2l0aChyZW1haW5pbmdQYXJ0KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbmNsdWRlc05leHQpIHtcbiAgICByZXR1cm4gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbmV4dEluZGV4OiBuZXh0SW5kZXggKyAxLFxuICAgICAgcmVtYWluaW5nUGFydDogcmVtYWluaW5nUGFydC5yZXBsYWNlKGNvbnRlbnQsIFwiXCIpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudChub2RlKSB7XG4gIGlmICghbm9kZSlcbiAgICByZXR1cm47XG4gIHJldHVybiB0b1N0cmluZyhub2RlKTtcbn1cbmZ1bmN0aW9uIGZpbmRPdmVybGFwKGEsIGIpIHtcbiAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKGEuZW5kc1dpdGgoYikpIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBpZiAoYS5pbmRleE9mKGIpID49IDApIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICByZXR1cm4gZmluZE92ZXJsYXAoYSwgYi5zdWJzdHJpbmcoMCwgYi5sZW5ndGggLSAxKSk7XG59XG5mdW5jdGlvbiByZXZlcnNlU3RyaW5nKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9jaGFycy9nZXRFbGVtZW50c1RvSGlnaGxpZ2h0LnRzXG5mdW5jdGlvbiBnZXRFbGVtZW50c1RvSGlnaGxpZ2h0KGVsZW1lbnQsIGNoYXJzLCBzdGFydEluZGV4ID0gMCwgaWdub3JlQ2hhcnMgPSBmYWxzZSkge1xuICBjb25zdCB0b1dyYXAgPSBbXTtcbiAgbGV0IGNoYXJzU29GYXIgPSBcIlwiO1xuICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBjaGFyc1NvRmFyID8gY2hhcnMucmVwbGFjZShjaGFyc1NvRmFyLCBcIlwiKSA6IGNoYXJzO1xuICAgICAgaWYgKHJlbWFpbmluZyA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF5YmVFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoIW1heWJlRWxlbWVudCB8fCBtYXliZUVsZW1lbnQudHlwZSAhPT0gXCJlbGVtZW50XCIgfHwgLy8gaWdub3JlIGFueSBwcmV2aW91c2x5IG1hdGNoZWQgY2hhcnMgd2l0aGluXG4gICAgICBPYmplY3QuaGFzT3duKFxuICAgICAgICBtYXliZUVsZW1lbnQucHJvcGVydGllcyA/PyB7fSxcbiAgICAgICAgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXG4gICAgICApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobWF5YmVFbGVtZW50KSB8fCBcIlwiO1xuICAgICAgaWYgKGNvbnRlbnQgPT09IGNoYXJzIHx8IGNoYXJzU29GYXIgKyBjb250ZW50ID09PSBjaGFycykge1xuICAgICAgICB0b1dyYXAucHVzaCh7IGVsZW1lbnQ6IG1heWJlRWxlbWVudCwgaW5kZXg6IGkgfSk7XG4gICAgICAgIHJldHVybiB0b1dyYXA7XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnMuc3RhcnRzV2l0aChjaGFyc1NvRmFyICsgY29udGVudCkpIHtcbiAgICAgICAgaWYgKG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICByZW1haW5pbmdQYXJ0OiByZW1haW5pbmcucmVwbGFjZShjb250ZW50LCBcIlwiKVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHRvV3JhcC5wdXNoKHsgZWxlbWVudDogZWxlbWVudHNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICAgIGNoYXJzU29GYXIgKz0gY29udGVudDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZyk7XG4gICAgICBjb25zdCBwYXJ0aWFsTWF0Y2ggPSBvdmVybGFwICYmIHJlbWFpbmluZy5zdGFydHNXaXRoKG92ZXJsYXApO1xuICAgICAgaWYgKHBhcnRpYWxNYXRjaCkge1xuICAgICAgICBjb25zdCBuZXh0UGFydCA9IHJlbWFpbmluZy5yZXBsYWNlKG92ZXJsYXAsIFwiXCIpO1xuICAgICAgICBpZiAobmV4dFBhcnQgIT09IFwiXCIgJiYgZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pICYmICFuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogbmV4dFBhcnRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdFBhcnRzID0gY29udGVudC5zcGxpdChvdmVybGFwKTtcbiAgICAgICAgY29uc3QgW2xlZnRQYXJ0LCByaWdodFBhcnQsIC4uLnJlc3RdID0gc3BsaXRQYXJ0cztcbiAgICAgICAgaWYgKHJpZ2h0UGFydCB8fCBsZWZ0UGFydCB8fCByZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB3aXRoTmV4dE5vZGUgPSBjb250ZW50ICsgKGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA/IGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA6IFwiXCIpO1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlT3ZlcmxhcCA9IGZpbmRPdmVybGFwKHdpdGhOZXh0Tm9kZSwgcmVtYWluaW5nKTtcbiAgICAgICAgICBjb25zdCBzcGxpdEluZGV4ID0gd2l0aE5leHROb2RlLmluZGV4T2YobmV4dE5vZGVPdmVybGFwKTtcbiAgICAgICAgICBpZiAoY2hhcnMuZW5kc1dpdGgob3ZlcmxhcCkgfHwgY2hhcnMuc3RhcnRzV2l0aChvdmVybGFwKSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRTdHJpbmcgPSByaWdodFBhcnQucmVwbGFjZShvdmVybGFwLCBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyU3RyaW5nID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRTdHJpbmcgPSBjb250ZW50LnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50Q29udGludWVzID0gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IG5leHRQYXJ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IFtuZXdFbGVtZW50LCB1cGRhdGVkSW5kZXhdID0gc3BsaXRFbGVtZW50KHtcbiAgICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAgIGVsZW1lbnRUb1dyYXA6IGVsZW1lbnRzW2ldLFxuICAgICAgICAgICAgICBpbm5lclN0cmluZyxcbiAgICAgICAgICAgICAgcmlnaHRTdHJpbmcsXG4gICAgICAgICAgICAgIGxlZnRTdHJpbmcsXG4gICAgICAgICAgICAgIHJlc3QsXG4gICAgICAgICAgICAgIG5leHRFbGVtZW50Q29udGludWVzLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgaWdub3JlQ2hhcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hhcnNTb0ZhciArPSBvdmVybGFwO1xuICAgICAgICAgICAgdG9XcmFwLnB1c2goe1xuICAgICAgICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICAgICAgICBpbmRleDogdXBkYXRlZEluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvV3JhcDtcbn1cblxuLy8gc3JjL2NoYXJzL3dyYXBIaWdobGlnaHRlZENoYXJzLnRzXG5mdW5jdGlvbiB3cmFwSGlnaGxpZ2h0ZWRDaGFycyhwYXJlbnRFbGVtZW50LCBlbGVtZW50c1RvV3JhcCwgb3B0aW9ucywgaWdub3JlV29yZCwgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMpIHtcbiAgaWYgKCFlbGVtZW50c1RvV3JhcCB8fCBlbGVtZW50c1RvV3JhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW3sgZWxlbWVudCB9XSA9IGVsZW1lbnRzVG9XcmFwO1xuICBpZiAoaWdub3JlV29yZCkge1xuICAgIGlmIChlbGVtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgIGVsZW1lbnQucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50c1RvV3JhcC5sZW5ndGggPiAxKSB7XG4gICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5zcGxpY2UoXG4gICAgICBlbGVtZW50c1RvV3JhcFswXS5pbmRleCxcbiAgICAgIGVsZW1lbnRzVG9XcmFwLmxlbmd0aCxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwibWFya1wiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7IFwiZGF0YS1oaWdobGlnaHRlZC1jaGFycy1tYXJrXCI6IFwiXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IGVsZW1lbnRzVG9XcmFwLm1hcCgoeyBlbGVtZW50OiBlbGVtZW50MyB9KSA9PiBlbGVtZW50MylcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbltlbGVtZW50c1RvV3JhcFswXS5pbmRleF07XG4gICAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdvcmRTdHIgPSBlbGVtZW50Mi5jaGlsZHJlbi5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBpc0VsZW1lbnQobm9kZSkgPyBub2RlLmNoaWxkcmVuWzBdIDogbnVsbDtcbiAgICAgIGlmIChpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgXCJcIik7XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLmlkc01hcC5nZXQod29yZFN0cik7XG4gICAgZWxlbWVudDIucHJvcGVydGllcyA9IGVsZW1lbnQyLnByb3BlcnRpZXMgfHwge307XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnNcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWNoYXJzLWlkXCJdID0gaWQ7XG4gICAgZWxlbWVudDIudGFnTmFtZSA9IFwibWFya1wiO1xuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzPy4oZWxlbWVudDIsIGlkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbeyBlbGVtZW50OiBlbGVtZW50MiB9XSA9IGVsZW1lbnRzVG9XcmFwO1xuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudDIuY2hpbGRyZW5bMF07XG4gICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZHNNYXAuZ2V0KHRleHRFbGVtZW50LnZhbHVlKTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzID0gZWxlbWVudDIucHJvcGVydGllcyB8fCB7fTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1jaGFycy1pZFwiXSA9IGlkO1xuICAgIGVsZW1lbnQyLnRhZ05hbWUgPSBcIm1hcmtcIjtcbiAgICBlbGVtZW50Mi5jaGlsZHJlbiA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgc3R5bGU6IGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGVcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGVsZW1lbnQyLmNoaWxkcmVuXG4gICAgICB9XG4gICAgXTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlID0gdm9pZCAwO1xuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzPy4oZWxlbWVudDIsIGlkKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hhcnNIaWdobGlnaHRlcihlbGVtZW50LCBjaGFyc0xpc3QsIG9wdGlvbnMsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGNvbnN0IHsgcmFuZ2VzID0gW10gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gdG9TdHJpbmcoZWxlbWVudCk7XG4gIGNoYXJzTGlzdC5mb3JFYWNoKChjaGFycywgaW5kZXgpID0+IHtcbiAgICBpZiAoY2hhcnMgJiYgdGV4dENvbnRlbnQ/LmluY2x1ZGVzKGNoYXJzKSkge1xuICAgICAgbGV0IHRleHRDb250ZW50MiA9IHRvU3RyaW5nKGVsZW1lbnQpO1xuICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKHRleHRDb250ZW50Mi5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXJzUmFuZ2UgPSByYW5nZXNbaW5kZXhdIHx8IFtdO1xuICAgICAgICBjb25zdCBpZCA9IGAke2NoYXJzfS0ke2luZGV4fWA7XG4gICAgICAgIG9wdGlvbnMuY291bnRlck1hcC5zZXQoaWQsIChvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSB8fCAwKSArIDEpO1xuICAgICAgICBjb25zdCBpZ25vcmVDaGFycyA9IGN1cnJlbnRDaGFyc1JhbmdlLmxlbmd0aCA+IDAgJiYgIWN1cnJlbnRDaGFyc1JhbmdlLmluY2x1ZGVzKG9wdGlvbnMuY291bnRlck1hcC5nZXQoaWQpID8/IC0xKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb1dyYXAgPSBnZXRFbGVtZW50c1RvSGlnaGxpZ2h0KFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgY2hhcnMsXG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBpZ25vcmVDaGFyc1xuICAgICAgICApO1xuICAgICAgICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB3cmFwSGlnaGxpZ2h0ZWRDaGFycyhcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGVsZW1lbnRzVG9XcmFwLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaWdub3JlQ2hhcnMsXG4gICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnNcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KFxuICAgICAgICAgIGVsZW1lbnRzVG9XcmFwW2VsZW1lbnRzVG9XcmFwLmxlbmd0aCAtIDFdLmluZGV4IC0gMixcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRleHRDb250ZW50MiA9IGVsZW1lbnQuY2hpbGRyZW4ubWFwKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IGlzRWxlbWVudChjaGlsZE5vZGUpID8gY2hpbGROb2RlLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgICAgICBpZiAocHJvcHMgJiYgIU9iamVjdC5oYXNPd24ocHJvcHMsIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIikgJiYgIU9iamVjdC5oYXNPd24ocHJvcHMsIFwiZGF0YS1oaWdobGlnaHRlZC1jaGFycy1tYXJrXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcoY2hpbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICBpZiAoIWlzRWxlbWVudChjaGlsZE5vZGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChPYmplY3QuaGFzT3duKGNoaWxkTm9kZS5wcm9wZXJ0aWVzLCBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCIpKSB7XG4gICAgICBjaGlsZE5vZGUucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gYXBwbHkoZWxlbWVudCwge1xuICB0cmVlLFxuICBsYW5nLFxuICB0aXRsZSxcbiAgY2FwdGlvbixcbiAgaW5saW5lID0gZmFsc2UsXG4gIGtlZXBCYWNrZ3JvdW5kID0gdHJ1ZSxcbiAgZ3JpZCA9IHRydWUsXG4gIGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gMSxcbiAgdGhlbWUsXG4gIG9uVmlzaXRUaXRsZSxcbiAgb25WaXNpdENhcHRpb25cbn0pIHtcbiAgZWxlbWVudC50YWdOYW1lID0gaW5saW5lID8gXCJzcGFuXCIgOiBcImZpZ3VyZVwiO1xuICBlbGVtZW50LnByb3BlcnRpZXNbXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS1maWd1cmVcIl0gPSBcIlwiO1xuICBjb25zdCBjb2RlRGF0YSA9IGVsZW1lbnQuY2hpbGRyZW5bMF0/LmRhdGE7XG4gIGVsZW1lbnQuY2hpbGRyZW4gPSBbdHJlZV0ubWFwKCh0cmVlMikgPT4ge1xuICAgIGNvbnN0IHByZSA9IHRyZWUyLmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBnZXRUaGVtZU5hbWVzKHRoZW1lKTtcbiAgICBjb25zdCB0aGVtZU5hbWVzU3RyaW5nID0gdGhlbWVOYW1lcy5qb2luKFwiIFwiKTtcbiAgICBpZiAoIShpc0VsZW1lbnQocHJlKSAmJiBwcmUucHJvcGVydGllcykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHByZS5jaGlsZHJlblswXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcmUucHJvcGVydGllcy5jbGFzc05hbWUpICYmIHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcInNoaWtpXCIpKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuZmlsdGVyKFxuICAgICAgICAoYykgPT4gYyAhPT0gXCJzaGlraVwiICYmIGMgIT09IFwic2hpa2ktdGhlbWVzXCIgJiYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiID8gIXRoZW1lTmFtZXMuaW5jbHVkZXMoYykgOiB0cnVlKVxuICAgICAgKTtcbiAgICAgIHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS5sZW5ndGggPiAwID8gY2xhc3NOYW1lIDogdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIWtlZXBCYWNrZ3JvdW5kKSB7XG4gICAgICBwcmUucHJvcGVydGllcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgcHJlLnByb3BlcnRpZXNbXCJkYXRhLWxhbmd1YWdlXCJdID0gbGFuZztcbiAgICBwcmUucHJvcGVydGllc1tcImRhdGEtdGhlbWVcIl0gPSB0aGVtZU5hbWVzU3RyaW5nO1xuICAgIGlmICghKGlzRWxlbWVudChjb2RlKSAmJiBjb2RlLnByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtbGFuZ3VhZ2VcIl0gPSBsYW5nO1xuICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtdGhlbWVcIl0gPSB0aGVtZU5hbWVzU3RyaW5nO1xuICAgIGNvZGUuZGF0YSA9IGNvZGVEYXRhO1xuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIGlmIChrZWVwQmFja2dyb3VuZCkge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgPSBwcmUucHJvcGVydGllcy5zdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBpZiAoZ3JpZCkge1xuICAgICAgaWYgKGNvZGUucHJvcGVydGllcy5zdHlsZSkge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgKz0gXCJkaXNwbGF5OiBncmlkO1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gXCJkaXNwbGF5OiBncmlkO1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0Lmhhc093bihjb2RlLnByb3BlcnRpZXMsIFwiZGF0YS1saW5lLW51bWJlcnNcIikpIHtcbiAgICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtbGluZS1udW1iZXJzLW1heC1kaWdpdHNcIl0gPSBsaW5lTnVtYmVyc01heERpZ2l0cy50b1N0cmluZygpLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRzID0gW107XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IGNhcHRpb24gPyBcImRpdlwiIDogXCJmaWdjYXB0aW9uXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLXRpdGxlXCI6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcsXG4gICAgICAgICAgXCJkYXRhLXRoZW1lXCI6IHRoZW1lTmFtZXNTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogdGl0bGUgfV1cbiAgICAgIH07XG4gICAgICBvblZpc2l0VGl0bGU/LihlbGVtZW50Q29udGVudCk7XG4gICAgICBmcmFnbWVudHMucHVzaChlbGVtZW50Q29udGVudCk7XG4gICAgfVxuICAgIGZyYWdtZW50cy5wdXNoKHByZSk7XG4gICAgaWYgKGNhcHRpb24pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJmaWdjYXB0aW9uXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWNhcHRpb25cIjogXCJcIixcbiAgICAgICAgICBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZyxcbiAgICAgICAgICBcImRhdGEtdGhlbWVcIjogdGhlbWVOYW1lc1N0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBjYXB0aW9uIH1dXG4gICAgICB9O1xuICAgICAgb25WaXNpdENhcHRpb24/LihlbGVtZW50Q29udGVudCk7XG4gICAgICBmcmFnbWVudHMucHVzaChlbGVtZW50Q29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudHM7XG4gIH0pLmZsYXRNYXAoKGMpID0+IGMpO1xufVxudmFyIGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIGhhc3RQYXJzZXIgPSB1bmlmaWVkKCkudXNlKHJlaHlwZVBhcnNlLCB7IGZyYWdtZW50OiB0cnVlIH0pO1xudmFyIHNyY19kZWZhdWx0ID0gcmVoeXBlUHJldHR5Q29kZTtcbmZ1bmN0aW9uIHJlaHlwZVByZXR0eUNvZGUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBncmlkID0gdHJ1ZSxcbiAgICB0aGVtZSA9IFwiZ2l0aHViLWRhcmstZGltbWVkXCIsXG4gICAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICAgIGRlZmF1bHRMYW5nID0gXCJcIixcbiAgICB0b2tlbnNNYXAgPSB7fSxcbiAgICBmaWx0ZXJNZXRhU3RyaW5nID0gKHYpID0+IHYsXG4gICAgZ2V0SGlnaGxpZ2h0ZXI6IGdldEhpZ2hsaWdodGVyJDEgPSBnZXRIaWdobGlnaHRlcixcbiAgICB0cmFuc2Zvcm1lcnMsXG4gICAgb25WaXNpdExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkTGluZSxcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycyxcbiAgICBvblZpc2l0VGl0bGUsXG4gICAgb25WaXNpdENhcHRpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHRoZW1lKTtcbiAgbGV0IGNhY2hlZEhpZ2hsaWdodGVyID0gZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKCFjYWNoZWRIaWdobGlnaHRlcikge1xuICAgIGNhY2hlZEhpZ2hsaWdodGVyID0gZ2V0SGlnaGxpZ2h0ZXIkMSh7XG4gICAgICB0aGVtZXM6IGlzSlNPTlRoZW1lKHRoZW1lKSB8fCB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyBbdGhlbWVdIDogT2JqZWN0LnZhbHVlcyh0aGVtZSksXG4gICAgICBsYW5nczogW1wicGxhaW50ZXh0XCJdXG4gICAgfSk7XG4gICAgZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZS5zZXQoa2V5LCBjYWNoZWRIaWdobGlnaHRlcik7XG4gIH1cbiAgY29uc3QgZGVmYXVsdENvZGVCbG9ja0xhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0TGFuZyA6IGRlZmF1bHRMYW5nLmJsb2NrIHx8IFwiXCI7XG4gIGNvbnN0IGRlZmF1bHRJbmxpbmVDb2RlTGFuZyA9IHR5cGVvZiBkZWZhdWx0TGFuZyA9PT0gXCJzdHJpbmdcIiA/IGRlZmF1bHRMYW5nIDogZGVmYXVsdExhbmcuaW5saW5lIHx8IFwiXCI7XG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMobGFuZywgbWV0YSkge1xuICAgIGNvbnN0IG11bHRpcGxlVGhlbWVzID0gIWlzSlNPTlRoZW1lKHRoZW1lKSAmJiB0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgPyB0aGVtZSA6IG51bGw7XG4gICAgY29uc3Qgc2luZ2xlVGhlbWUgPSBpc0pTT05UaGVtZSh0aGVtZSkgfHwgdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBsYW5nLFxuICAgICAgbWV0YTogeyBfX3JhdzogbWV0YSB9LFxuICAgICAgdHJhbnNmb3JtZXJzLFxuICAgICAgZGVmYXVsdENvbG9yOiB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IGZhbHNlLFxuICAgICAgLi4ubXVsdGlwbGVUaGVtZXMgPyB7IHRoZW1lczogbXVsdGlwbGVUaGVtZXMgfSA6IHsgdGhlbWU6IHNpbmdsZVRoZW1lIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhc3luYyAodHJlZSkgPT4ge1xuICAgIGNvbnN0IGxhbmdzVG9Mb2FkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBoaWdobGlnaHRlciA9IGF3YWl0IGNhY2hlZEhpZ2hsaWdodGVyO1xuICAgIGlmICghaGlnaGxpZ2h0ZXIpXG4gICAgICByZXR1cm47XG4gICAgdmlzaXQodHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50LCBfLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50KSkge1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsYW5nID0gZ2V0SW5saW5lQ29kZUxhbmcodmFsdWUsIGRlZmF1bHRJbmxpbmVDb2RlTGFuZyk7XG4gICAgICAgIGlmIChsYW5nICYmIGxhbmdbMF0gIT09IFwiLlwiKSB7XG4gICAgICAgICAgbGFuZ3NUb0xvYWQuYWRkKGxhbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0NvZGUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgY29kZUVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzRWxlbWVudChjb2RlRWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhbmcgfSA9IHBhcnNlQmxvY2tNZXRhU3RyaW5nKFxuICAgICAgICAgIGNvZGVFbGVtZW50LFxuICAgICAgICAgIGZpbHRlck1ldGFTdHJpbmcsXG4gICAgICAgICAgZGVmYXVsdENvZGVCbG9ja0xhbmdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxhbmcpIHtcbiAgICAgICAgICBsYW5nc1RvTG9hZC5hZGQobGFuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICBBcnJheS5mcm9tKGxhbmdzVG9Mb2FkKS5tYXAoKGxhbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVyLmxvYWRMYW5ndWFnZShcbiAgICAgICAgICAgICAgbGFuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICB2aXNpdCh0cmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQsIF8sIHBhcmVudCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGtlZXBMYW5nUGFydCA9IC9cXFxcezpbYS16QS1aLi1dK30kLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IGtlZXBMYW5nUGFydCA/IHZhbHVlLnJlcGxhY2UoL1xcXFwoezpbYS16QS1aLi1dK30pJC8sIFwiJDFcIikgOiB2YWx1ZS5yZXBsYWNlKC97OlthLXpBLVouLV0rfSQvLCBcIlwiKTtcbiAgICAgICAgdGV4dEVsZW1lbnQudmFsdWUgPSBzdHJpcHBlZFZhbHVlO1xuICAgICAgICBjb25zdCBsYW5nID0ga2VlcExhbmdQYXJ0ID8gXCJcIiA6IGdldElubGluZUNvZGVMYW5nKHZhbHVlLCBkZWZhdWx0SW5saW5lQ29kZUxhbmcpO1xuICAgICAgICBjb25zdCBpc0xhbmcgPSBsYW5nWzBdICE9PSBcIi5cIjtcbiAgICAgICAgaWYgKCFsYW5nKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvZGVUcmVlO1xuICAgICAgICBpZiAoaXNMYW5nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKGxhbmcpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKFwicGxhaW50ZXh0XCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGhlbWVOYW1lcyA9IGdldFRoZW1lTmFtZXModGhlbWUpO1xuICAgICAgICAgIGNvbnN0IGlzTXVsdGlUaGVtZSA9IHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiAmJiAhaXNKU09OVGhlbWUodGhlbWUpO1xuICAgICAgICAgIGNvbnN0IHRoZW1lS2V5cyA9IGlzTXVsdGlUaGVtZSA/IE9iamVjdC5rZXlzKHRoZW1lKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgY29sb3JzQnlUaGVtZSA9IHRoZW1lTmFtZXMubWFwKFxuICAgICAgICAgICAgKG5hbWUpID0+IG5hbWUgPyBoaWdobGlnaHRlci5nZXRUaGVtZShuYW1lKS5zZXR0aW5ncy5maW5kKFxuICAgICAgICAgICAgICAoeyBzY29wZSB9KSA9PiBzY29wZT8uaW5jbHVkZXModG9rZW5zTWFwW2xhbmcuc2xpY2UoMSldID8/IGxhbmcuc2xpY2UoMSkpXG4gICAgICAgICAgICApPy5zZXR0aW5ncy5mb3JlZ3JvdW5kID8/IFwiaW5oZXJpdFwiIDogXCJpbmhlcml0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc011bHRpVGhlbWUgJiYgdGhlbWVLZXlzKSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGA8cHJlPjxjb2RlPjxzcGFuIHN0eWxlPVwiJHt0aGVtZUtleXMubWFwKChrZXkyLCBpKSA9PiBgLS1zaGlraS0ke2tleTJ9OiR7Y29sb3JzQnlUaGVtZVtpXX1gKS5qb2luKFwiO1wiKX1cIj4ke3N0cmlwcGVkVmFsdWV9PC9zcGFuPjwvY29kZT48L3ByZT5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGA8cHJlPjxjb2RlPjxzcGFuIHN0eWxlPVwiY29sb3I6JHtjb2xvcnNCeVRoZW1lWzBdfVwiPiR7c3RyaXBwZWRWYWx1ZX08L3NwYW4+PC9jb2RlPjwvcHJlPmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0KGNvZGVUcmVlLCBcImVsZW1lbnRcIiwgcmVwbGFjZUxpbmVDbGFzcyk7XG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmVlOiBjb2RlVHJlZSxcbiAgICAgICAgICBsYW5nOiBpc0xhbmcgPyBsYW5nIDogXCIudG9rZW5cIixcbiAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAga2VlcEJhY2tncm91bmQsXG4gICAgICAgICAgdGhlbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0NvZGUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgY29kZUVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzRWxlbWVudChjb2RlRWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGNvZGVFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBjb25zdCB7IHRpdGxlLCBjYXB0aW9uLCBtZXRhLCBsYW5nIH0gPSBwYXJzZUJsb2NrTWV0YVN0cmluZyhcbiAgICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgICBmaWx0ZXJNZXRhU3RyaW5nLFxuICAgICAgICAgIGRlZmF1bHRDb2RlQmxvY2tMYW5nXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbGFuZyB8fCBsYW5nID09PSBcIm1hdGhcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzID0gW107XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG1ldGEubWF0Y2hBbGwoL1xcQlxceyguKj8pXFx9XFxCL2cpO1xuICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIGxpbmVOdW1iZXJzLnB1c2goLi4ucmFuZ2VQYXJzZXIyKG1hdGNoWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDA7XG4gICAgICAgIGNvbnN0IGxpbmVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3ROdW1iZXJzID0gW107XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdElkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY2hhcnNNYXRjaGVzID0gbWV0YSA/IFtcbiAgICAgICAgICAuLi5tZXRhLm1hdGNoQWxsKFxuICAgICAgICAgICAgLyg/PGRlbGltaXRlcj5bXCIvXSkoPzxjaGFycz4uKj8pXFxrPGRlbGltaXRlcj4oPzxjaGFyc0lkQW5kT3JSYW5nZT5cXFMqKS9nXG4gICAgICAgICAgKVxuICAgICAgICBdIDogdm9pZCAwO1xuICAgICAgICBsaW5lTnVtYmVycy5mb3JFYWNoKChsaW5lTnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBnZXRMaW5lSWQobGluZU51bWJlciwgbWV0YSk7XG4gICAgICAgICAgaWQgJiYgbGluZUlkTWFwLnNldChsaW5lTnVtYmVyLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFyc01hdGNoZXMpKSB7XG4gICAgICAgICAgY2hhcnNNYXRjaGVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhcnMsIGNoYXJzSWRBbmRPclJhbmdlIH0gPSBuYW1lLmdyb3VwcztcbiAgICAgICAgICAgIGNoYXJzTGlzdC5wdXNoKGNoYXJzKTtcbiAgICAgICAgICAgIGlmIChjaGFyc0lkQW5kT3JSYW5nZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBjaGFyc0xpc3ROdW1iZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgW3JhbmdlLCBpZF0gPSBjaGFyc0lkQW5kT3JSYW5nZS5zcGxpdChcIiNcIik7XG4gICAgICAgICAgICAgIHJhbmdlICYmIGNoYXJzTGlzdE51bWJlcnMucHVzaChyYW5nZVBhcnNlcjIocmFuZ2UpKTtcbiAgICAgICAgICAgICAgaWQgJiYgY2hhcnNMaXN0SWRNYXAuc2V0KGNoYXJzLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgICAgICAgbGV0IGNvZGVUcmVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhsYW5nLCBtZXRhKSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKFxuICAgICAgICAgICAgICBzdHJpcHBlZFZhbHVlLFxuICAgICAgICAgICAgICBnZXRPcHRpb25zKFwicGxhaW50ZXh0XCIsIG1ldGEpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZUNvdW50ZXIgPSAwO1xuICAgICAgICBjb25zdCBjaGFyc0hpZ2hsaWdodGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICByYW5nZXM6IGNoYXJzTGlzdE51bWJlcnMsXG4gICAgICAgICAgaWRzTWFwOiBjaGFyc0xpc3RJZE1hcCxcbiAgICAgICAgICBjb3VudGVyTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0KGNvZGVUcmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQyKSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQyLnRhZ05hbWUgPT09IFwiY29kZVwiICYmIC9zcmVibXVOZW5pTHdvaHMoPyEoLiopKFxcLykpLy50ZXN0KHJldmVyc2VTdHJpbmcobWV0YSkpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudDIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lLW51bWJlcnNcIl0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlcnNTdGFydEF0TWF0Y2ggPSByZXZlcnNlU3RyaW5nKG1ldGEpLm1hdGNoKFxuICAgICAgICAgICAgICAvKD86XFx9KFxcZCspeyk/c3JlYm11TmVuaUx3b2hzKD8hKC4qKShcXC8pKS9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFydE51bWJlclN0cmluZyA9IGxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoPy5bMV07XG4gICAgICAgICAgICBpZiAoc3RhcnROdW1iZXJTdHJpbmcpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHN0YXJ0TnVtYmVyU3RyaW5nID8gTnVtYmVyKHJldmVyc2VTdHJpbmcoc3RhcnROdW1iZXJTdHJpbmcpKSAtIDEgOiAwO1xuICAgICAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cyA9IHN0YXJ0QXQ7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Mi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllcy5zdHlsZSA9IGBjb3VudGVyLXNldDogbGluZSAke3N0YXJ0QXR9O2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudDIucHJvcGVydGllcz8uY2xhc3NOYW1lKSAmJiBlbGVtZW50Mi5wcm9wZXJ0aWVzPy5jbGFzc05hbWU/LlswXSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgICAgICAgIGlmIChncmlkICYmIHRvU3RyaW5nKGVsZW1lbnQyKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5jaGlsZHJlbiA9IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCIgXCIgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlTGluZUNsYXNzKGVsZW1lbnQyKTtcbiAgICAgICAgICAgIG9uVmlzaXRMaW5lPy4oZWxlbWVudDIpO1xuICAgICAgICAgICAgbGluZUNvdW50ZXIrKztcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVycy5pbmNsdWRlcyhsaW5lQ291bnRlcikpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtbGluZVwiXSA9IFwiXCI7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVJZCA9IGxpbmVJZE1hcC5nZXQobGluZUNvdW50ZXIpO1xuICAgICAgICAgICAgICBpZiAobGluZUlkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtbGluZS1pZFwiXSA9IGxpbmVJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lPy4oZWxlbWVudDIsIGxpbmVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFyc0hpZ2hsaWdodGVyKFxuICAgICAgICAgICAgICBlbGVtZW50MixcbiAgICAgICAgICAgICAgY2hhcnNMaXN0LFxuICAgICAgICAgICAgICBjaGFyc0hpZ2hsaWdodGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmVlOiBjb2RlVHJlZSxcbiAgICAgICAgICBsYW5nLFxuICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgIGNhcHRpb24sXG4gICAgICAgICAga2VlcEJhY2tncm91bmQsXG4gICAgICAgICAgZ3JpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyc01heERpZ2l0cyxcbiAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICBvblZpc2l0VGl0bGUsXG4gICAgICAgICAgb25WaXNpdENhcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHNyY19kZWZhdWx0IGFzIGRlZmF1bHQsIHJlaHlwZVByZXR0eUNvZGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;